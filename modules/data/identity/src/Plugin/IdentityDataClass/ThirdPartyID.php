<?php

namespace Drupal\identity\Plugin\IdentityDataClass;

use Drupal\Core\Extension\ModuleHandlerInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Logger\LoggerChannelFactoryInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\entity\BundleFieldDefinition;
use Drupal\identity\Entity\IdentityData;
use Drupal\identity\Entity\IdentityDataInterface;
use Drupal\identity\Entity\IdentityDataStorage;
use Drupal\identity\Entity\IdentityStorage;
use Drupal\identity\IdentityMatch;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Class ThirdPartyID
 *
 * @IdentityDataClass(
 *   id = "third_party_id",
 *   label = @Translation("Third Party ID"),
 *   plural_label = @Translation("Third Party IDs"),
 *   form_defaults = {
 *     "hidden" = TRUE,
 *   }
 * );
 *
 * @package Drupal\identity\Plugin\IdentityDataClass
 */
class ThirdPartyID extends IdentityDataClassBase {

  const TYPE_SSN = 'ssn';
  const TYPE_CK = 'ck';
  const TYPE_BKW = 'bkw';

  /**
   * @var \Drupal\Core\Extension\ModuleHandlerInterface
   */
  protected $moduleHandler;

  /**
   * @var \Drupal\Core\Logger\LoggerChannelFactoryInterface
   */
  protected $loggerChannelFactory;

  /**
   * Get the encrypted default value.
   *
   * @param \Drupal\identity\Entity\IdentityData $data
   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
   *
   * @return array
   */
  public static function isEncryptedDefaultValue(IdentityData $data, FieldDefinitionInterface $field_definition) {
    $plugin = $data->getClass();

    if (
      !$data->type->isEmpty() && is_callable([$plugin, 'typeInfo'])
      && ($info = $plugin->typeInfo()) && isset($info[$data->type->value])
      && !empty($info[$data->type->value]['encrypted'])
    ) {
      return ['value' => TRUE];
    }

    return [];
  }

  /**
   * Get the one to one.
   *
   * @param \Drupal\identity\Entity\IdentityData $data
   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
   *
   * @return array
   */
  public static function isOneToOneDefaultValue(IdentityData $data, FieldDefinitionInterface $field_definition) {
    $plugin = $data->getClass();

    if (
      !$data->type->isEmpty() && is_callable([$plugin, 'typeInfo'])
      && ($info = $plugin->typeInfo()) && isset($info[$data->type->value])
      && !empty($info[$data->type->value]['one_to_one'])
    ) {
      return ['value' => TRUE];
    }

    return [];
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      $container->get('entity_type.manager')->getStorage('identity'),
      $container->get('entity_type.manager')->getStorage('identity_data'),
      $container->get('module_handler'),
      $container->get('logger.factory')
    );
  }

  /**
   * ThirdPartyID constructor.
   *
   * @param array $configuration
   * @param $plugin_id
   * @param $plugin_definition
   * @param \Drupal\identity\Entity\IdentityStorage $identity_storage
   * @param \Drupal\identity\Entity\IdentityDataStorage $identity_data_storage
   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
   */
  public function __construct(
    array $configuration,
    $plugin_id,
    $plugin_definition,
    IdentityStorage $identity_storage,
    IdentityDataStorage $identity_data_storage,
    ModuleHandlerInterface $module_handler,
    LoggerChannelFactoryInterface $logger_channel_factory
  ) {
    parent::__construct($configuration, $plugin_id, $plugin_definition, $identity_storage, $identity_data_storage);

    $this->moduleHandler = $module_handler;
    $this->loggerChannelFactory = $logger_channel_factory;
  }

  /**
   * {@inheritdoc}
   */
  public function createData($type, $reference, $value = NULL) {
    $data = parent::createData($type, $reference, $value);

    if (is_string($value) || is_numeric($value)) {
      $data->value = $value;

      $types = $this->typeInfo();
      if (isset($types[$type]['default_third_party'])) {
        $data->third_party = $types[$type]['default_third_party'];
      }
    }
    else if (is_array($value)) {
      $data->value = $value['value'];
      $data->third_party = $value['third_party'];
    }

    return $data;
  }

  /**
   * {@inheritdoc}
   */
  public function acquisitionPriority(IdentityData $data) {
    if ($data->type->value == static::TYPE_SSN) {
      return 100000;
    }

    return parent::acquisitionPriority($data); // TODO: Change the autogenerated stub
  }

  /**
   * {@inheritdoc}
   */
  public function findMatches(IdentityData $data) {
    /** @var \Drupal\identity\Entity\Query\IdentityDataQueryInterface $query */
    $query = $this->identityDataStorage->getQuery('AND');
    $query->identityDistinct();
    $query->condition('class', $this->pluginId);
    $query->condition('type', $data->type->value);

    if (isset($data->third_party->value)) {
      $query->condition('third_party', $data->third_party->value);
    }

    if ($data->is_encrypted->value) {
      $value = $data->value->value;

      // We store the last 4 of any encrypted ID for searching.
      $trimmed_and_cleaned = trim(str_replace(
        ['-', '_', ' '],
        '',
        $value
      ));
      $value_search = str_pad(
        substr($trimmed_and_cleaned, -4),
        strlen($trimmed_and_cleaned),
        'X',
        STR_PAD_LEFT
      );

      $query->condition('value_searchable', $value_search);
    }
    else {
      $query->condition('value_searchable', $data->value->value);
    }

    /** @var \Drupal\identity\IdentityMatch[] $matches */
    $matches = [];

    /** @var \Drupal\identity\Entity\IdentityData $match_data */
    foreach ($this->identityDataStorage->loadMultiple($query->execute()) as $match_data) {
      $score = 100;
      if ($data->is_encrypted->value) {
        if ($data->value->value == $match_data->value->value){
          // If the SSNs match exactly boost the score.
          $score = 10000;
        }
      }

      /** @var IdentityData $match_data */
      if (!isset($matches[$match_data->getIdentityId()]) || $score > $matches[$match_data->getIdentityId()]->getScore()) {
        /** @var \Drupal\identity\Entity\IdentityData $match_Data */
        $matches[$match_data->getIdentityId()] = new IdentityMatch($data, $match_data, $score);
      }
    }

    return $matches;
  }

  /**
   * {@identity}
   */
  public function supportOrOppose(IdentityData $search_data, IdentityMatch $match) {
    $identity = $match->getIdentity();

    foreach ($identity->getData($this->pluginId, ['type' => $search_data->type->value]) as $match_data) {
      if (
        $search_data->third_party->value == $match_data->third_party->value &&
        $search_data->value->value == $match_data->value->value
      ) {
        $match->supportMatch($search_data, $match_data, ($search_data->is_encrypted->value ? 100 : 10000), ['full', 'last4']);
      }

      if (
        $search_data->third_party->value == $match_data->third_party->value &&
        $search_data->is_one_to_one->value &&
        $search_data->value->value != $match_data->value->value
      ) {
        $match->opposeMatch($search_data, $match_data, ($search_data->is_encrypted->value ? 100 : 10000));
      }
    }
  }

  /**
   * {@inheritdoc}
   */
  public function buildFieldDefinitions() {
    $fields = parent::buildFieldDefinitions();

    $fields['third_party'] = BundleFieldDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Third Party'))
      ->setDisplayConfigurable('view', TRUE)
      ->setDisplayConfigurable('form', TRUE);

    $fields['value'] = BundleFieldDefinition::create('string')
      ->setLabel(new TranslatableMarkup('ID'))
      ->setDisplayConfigurable('view', TRUE)
      ->setDisplayOptions('form', [
        'type' => 'textfield',
      ])
      ->setDisplayConfigurable('form', TRUE);

    $fields['value_encrypted'] = BundleFieldDefinition::create('text')
      ->setLabel(new TranslatableMarkup('ID (Encrypted)'));

    $fields['value_searchable'] = BundleFieldDefinition::create('string')
      ->setLabel(new TranslatableMarkup('ID (Searchable)'));

    $fields['is_encrypted'] = BundleFieldDefinition::create('boolean')
      ->setLabel(new TranslatableMarkup('Is Encrypted?'))
      ->setDefaultValueCallback(static::class.'::isEncryptedDefaultValue')
      ->setDisplayConfigurable('view', TRUE)
      ->setDisplayConfigurable('form', TRUE);

    $fields['is_one_to_one'] = BundleFieldDefinition::create('boolean')
      ->setLabel(new TranslatableMarkup('Is one to one'))
      ->setDefaultValueCallback(static::class.'::isOneToOneDefaultValue')
      ->setDisplayConfigurable('view', TRUE)
      ->setDisplayConfigurable('form', TRUE);

    return $fields;
  }

  public function typeOptions() {
    $options = [];

    foreach ($this->typeInfo() as $type => $info) {
      $options[$type] = $info['label'];
    }

    return $options;
  }

  public function typeInfo() {
    $default_types = [];

    // @todo: Move defaults to hook.
    $default_types[static::TYPE_SSN] = [
      'label' => new TranslatableMarkup('Social Security Number'),
      'encrypted' => TRUE,
      'one_to_one' => TRUE,
      'default_third_party' => 'ssn',
    ];
    $default_types[static::TYPE_BKW] = [
      'label' => new TranslatableMarkup('BKWatch ID'),
      'encrypted' => FALSE,
      'default_third_party' => 'BK Watch',
    ];
    $default_types[static::TYPE_CK] = [
      'label' => new TranslatableMarkup('CounselKit'),
      'encrypted' => FALSE,
    ];

    $types = $this->moduleHandler->invokeAll('identity_third_party_id_type_info');
    $types += $default_types;
    $this->moduleHandler->alter('identity_third_party_id_type_info', $types);

    return $types;
  }

  /**
   * @param \Drupal\identity\Entity\IdentityData $data
   */
  public function preSaveData(IdentityData $data) {
    if ($data->is_encrypted->value) {
      $value = $data->value->value;

      $data->value = [];
      $data->value_encrypted = $this->encryptValue($value);

      // We store the last 4 of any encrypted ID for searching.
      $trimmed_and_cleaned = trim(str_replace(
        ['-', '_', ' '],
        '',
        $value
      ));
      $data->value_searchable = str_pad(
        substr($trimmed_and_cleaned, -4),
        strlen($trimmed_and_cleaned),
        'X',
        STR_PAD_LEFT
      );

      $data->__unencypted_value = $value;
    }
    else {
      $data->value_searchable = $data->value->value;
    }
  }

  /**
   * @param \Drupal\identity\Entity\IdentityData $data
   */
  public function postSaveData(IdentityData $data) {
    if ($data->is_encrypted->value && $data->__unencrypted_value) {
      $data->value = $data->__unencrypted_value;
      unset($data->__unencrypted_value);
    }
  }

  /**
   * @param \Drupal\identity\Entity\IdentityData $data
   */
  public function storageLoadData(IdentityData $data) {
    if ($data->is_encrypted->value) {
      $data->value = $this->decryptValue($data->value_encrypted->value);
    }
  }

  protected function encryptValue($value) {
    if (!($key = @file_get_contents('private://.third_party_id.key'))) {
      $this->loggerChannelFactory->get('identity')->warning(
        'Creating new encrytion key for third party ids'
      );

      $key = random_bytes(SODIUM_CRYPTO_SECRETBOX_KEYBYTES);

      file_put_contents('private://.third_party_id.key', $key);
    }

    $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES);
    $cipher = sodium_crypto_secretbox($value, $nonce, $key);

    return base64_encode($nonce.$cipher);
  }

  protected function decryptValue($encrypted) {
    $decoded = base64_decode($encrypted);

    $nonce = mb_substr($decoded, 0, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, '8bit');
    $cipher = mb_substr($decoded, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, NULL, '8bit');
    $key = @file_get_contents('private://.third_party_id.key');

    if (empty($key)) {
      throw new \Exception('No encryption key discoved');
    }

    $plaintext = sodium_crypto_secretbox_open($cipher, $nonce, $key);

    return $plaintext;
  }

  /**
   * {@inheritdoc}
   */
  public function possibleMatchSupportLevels(IdentityDataInterface $search_data) {
    $levels = ['full'];

    if ($search_data->type->value == static::TYPE_SSN) {
      $levels[] = 'last4';
    }

    return $levels;
  }
}
